<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 無限人群跑酷 (Three.js)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif; }
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            font-weight: 900;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 10;
        }
        #tutorial {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            pointer-events: none;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 0.4; } 100% { opacity: 0.8; } }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="ui">34</div>
    <div id="tutorial">拖曳滑鼠或手指移動 / 衝向藍色大門！</div>
    
    <script type="module">
        import * as THREE from 'three';

        // --- 遊戲參數設定 ---
        const MAX_INSTANCES = 30000; // 上限設為 3萬人 (利用 GPU 加速)
        const START_COUNT = 34;
        const RUN_SPEED = 0.5; // 前進速度
        const STRAFE_SPEED = 0.15; // 左右移動靈敏度
        const MOB_SPREAD = 0.8; // 人群擁擠程度
        
        // --- 初始化場景 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // 天空藍
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60); // 遠處霧氣

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 12, 15);
        camera.lookAt(0, 0, -5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 燈光 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        scene.add(dirLight);

        // --- 地板 ---
        const floorGeo = new THREE.PlaneGeometry(40, 200);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- 玩家人群 (InstancedMesh 技術) ---
        // 使用圓柱體模擬小人
        const bodyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
        bodyGeo.translate(0, 0.6, 0); // 調整中心點到底部
        const bodyMat = new THREE.MeshLambertMaterial({ color: 0x29b6f6 });
        
        const mesh = new THREE.InstancedMesh(bodyGeo, bodyMat, MAX_INSTANCES);
        mesh.castShadow = true;
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // 標記為動態更新
        scene.add(mesh);

        // 人群數據
        let mobCount = START_COUNT;
        let dummy = new THREE.Object3D();
        let mobData = []; // 儲存每個人的相對位置 {x, z, speed}

        // 初始化人群
        for (let i = 0; i < MAX_INSTANCES; i++) {
            // 預先生成隨機偏移量，讓隊伍看起來自然
            let angle = Math.random() * Math.PI * 2;
            let radius = Math.random() * 2; 
            mobData.push({
                x: 0, 
                z: 0,
                offsetX: (Math.random() - 0.5) * 1,
                offsetZ: (Math.random() - 0.5) * 1,
                active: i < START_COUNT
            });
            // 初始把不用的藏在地底
            dummy.position.set(0, -100, 0);
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
        }

        // --- 門 (Gates) ---
        let gates = [];
        const gateGroup = new THREE.Group();
        scene.add(gateGroup);

        function createGateTexture(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // 半透明背景
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 256, 128);
            
            // 邊框
            ctx.strokeStyle = "white";
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, 256, 128);

            // 文字
            ctx.fillStyle = 'white';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 64);

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function spawnGate(zPos) {
            const isLeft = Math.random() > 0.5;
            const type = Math.random() > 0.5 ? 'add' : 'mult';
            
            let val;
            let text;
            if(type === 'add') {
                val = Math.floor(Math.random() * 50) + 20;
                text = "+" + val;
            } else {
                val = Math.floor(Math.random() * 3) + 2;
                text = "x" + val;
            }

            const geometry = new THREE.PlaneGeometry(8, 4);
            // 藍色半透明
            const material = new THREE.MeshBasicMaterial({ 
                map: createGateTexture(text, 'rgba(41, 182, 246, 0.6)'),
                transparent: true,
                side: THREE.DoubleSide
            });

            const gate = new THREE.Mesh(geometry, material);
            
            // 隨機放左或右，或者兩個並排
            // 這裡簡化為隨機生成一對
            gate.position.set(isLeft ? -5 : 5, 2, zPos);
            
            gate.userData = { type: type, value: val, hit: false };
            gateGroup.add(gate);
            gates.push(gate);

            // 生成另一個門 (壞的或是另一個選項)
            const type2 = 'add';
            const val2 = Math.floor(Math.random() * 10) + 1;
            const gate2 = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
                map: createGateTexture("+" + val2, 'rgba(41, 182, 246, 0.6)'),
                transparent: true,
                side: THREE.DoubleSide
            }));
            gate2.position.set(isLeft ? 5 : -5, 2, zPos);
            gate2.userData = { type: 'add', value: val2, hit: false };
            gateGroup.add(gate2);
            gates.push(gate2);
        }

        // 預先生成一些門
        for(let i=1; i<10; i++) {
            spawnGate(-i * 40);
        }

        // --- 控制邏輯 ---
        let playerX = 0;
        let targetX = 0;
        let globalZ = 0; // 玩家前進的距離

        // 處理輸入
        function onInput(x) {
            // 將螢幕座標轉換為 -1 到 1
            const ndc = (x / window.innerWidth) * 2 - 1;
            // 映射到跑道寬度 (-8 到 8)
            targetX = ndc * 10;
        }

        document.addEventListener('mousemove', e => onInput(e.clientX));
        document.addEventListener('touchmove', e => onInput(e.touches[0].clientX));

        // 更新 UI
        const uiCounter = document.getElementById('ui');

        // --- 數學運算 ---
        function applyMath(type, value) {
            let newCount = mobCount;
            if (type === 'add') newCount += value;
            if (type === 'mult') newCount *= value;

            if (newCount > MAX_INSTANCES) newCount = MAX_INSTANCES;

            // 激活新的人偶
            for (let i = mobCount; i < newCount; i++) {
                mobData[i].active = true;
                // 新人偶從中心生成
                mobData[i].x = playerX + (Math.random()-0.5)*2; 
                mobData[i].z = globalZ + (Math.random()-0.5)*2;
            }
            mobCount = Math.floor(newCount);
            uiCounter.innerText = mobCount;
            
            // 簡單的特效：彈一下
            uiCounter.style.transform = "translateX(-50%) scale(1.5)";
            setTimeout(() => uiCounter.style.transform = "translateX(-50%) scale(1)", 200);
        }

        // --- 主循環 ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. 移動邏輯
            globalZ -= RUN_SPEED; // 往負 Z 軸移動
            playerX += (targetX - playerX) * 0.1; // 平滑移動 X

            // 相機跟隨
            camera.position.z = globalZ + 15;
            camera.position.x = playerX * 0.5; // 相機稍微跟著左右擺動
            floor.position.z = globalZ; // 地板跟著走 (看起來像無限)

            // 2. 更新人群 (InstancedMesh)
            // 我們根據人群數量動態調整隊形的半徑
            let formationRadius = Math.sqrt(mobCount) * 0.15; 
            if (formationRadius < 1) formationRadius = 1;

            let count = 0;
            for (let i = 0; i < MAX_INSTANCES; i++) {
                if (mobData[i].active) {
                    // 目標位置：以 playerX 為中心
                    // 加上每個人的隨機偏移，並隨著時間推擠
                    
                    // 簡單的群體模擬：往 playerX 靠攏，但保持間距
                    let tx = playerX + mobData[i].offsetX * formationRadius;
                    let tz = globalZ + mobData[i].offsetZ * formationRadius;
                    
                    // 讓他們慢慢排好隊
                    mobData[i].x += (tx - mobData[i].x) * 0.1;
                    mobData[i].z = tz; // Z軸直接鎖定

                    dummy.position.set(mobData[i].x, 0, mobData[i].z);
                    dummy.rotation.x = -0.2; // 稍微前傾，像在跑步
                    // 左右搖擺動畫
                    dummy.rotation.z = Math.sin(Date.now() * 0.02 + i) * 0.1;
                    
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    count++;
                } else {
                    // 隱藏未激活的
                    dummy.position.set(0, -100, 0);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
            }
            mesh.instanceMatrix.needsUpdate = true;
            mesh.count = MAX_INSTANCES; // 總是渲染所有 (因為隱藏的在地底)

            // 3. 檢查門的碰撞與生成
            for (let i = gates.length - 1; i >= 0; i--) {
                let g = gates[i];
                
                // 碰撞檢測 (Z軸接近且X軸在範圍內)
                // 門的位置在 g.position
                // 玩家位置在 globalZ, playerX
                if (!g.userData.hit && Math.abs(g.position.z - globalZ) < 1) {
                    // 檢查 X 軸 (門寬約 8)
                    if (Math.abs(g.position.x - playerX) < 4) {
                        applyMath(g.userData.type, g.userData.value);
                        g.userData.hit = true;
                        g.visible = false; // 撞到後消失
                    }
                }

                // 回收舊門，生成新門
                if (g.position.z > globalZ + 10) {
                    gateGroup.remove(g);
                    gates.splice(i, 1);
                    // 生成一個新的在遠處
                    spawnGate(globalZ - 100); 
                }
            }

            renderer.render(scene, camera);
        }

        // 處理視窗縮放
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>