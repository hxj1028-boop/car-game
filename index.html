<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 跑酷：Boss 戰役</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Arial Black', sans-serif; }
        
        /* UI 介面 */
        #ui-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #mob-count {
            margin-top: 20px;
            font-size: 50px;
            color: #00e5ff;
            -webkit-text-stroke: 2px #006064;
            text-shadow: 3px 3px 0px rgba(0,0,0,0.3);
        }

        #boss-ui {
            display: none; /* 只有打王時顯示 */
            position: absolute;
            top: 100px;
            width: 80%;
            max-width: 600px;
        }

        #boss-hp-bar {
            width: 100%;
            height: 30px;
            background: #333;
            border: 3px solid white;
            border-radius: 15px;
            overflow: hidden;
        }

        #boss-hp-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff5252);
            transition: width 0.1s;
        }

        #boss-name {
            text-align: center;
            color: #ff5252;
            font-size: 24px;
            margin-bottom: 5px;
            text-shadow: 1px 1px 2px black;
        }

        #game-over {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: white;
            text-shadow: 0 0 10px black;
            text-align: center;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="ui-container">
        <div id="mob-count">34</div>
        <div id="boss-ui">
            <div id="boss-name">FINAL BOSS (2000 HP)</div>
            <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
        </div>
        <div id="game-over"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- 遊戲設定 ---
        const CONFIG = {
            maxInstances: 20000, // 最大人數 (GPU緩衝區)
            startCount: 34,
            gateCount: 30,       // 總共幾道門
            gateInterval: 40,    // 門的間距
            runSpeed: 0.6,
            laneWidth: 14,       // 跑道寬度
            bossHP: 2000,
            damagePerUnit: 0.3
        };

        // 狀態管理
        let state = 'RUNNING'; // 'RUNNING', 'BOSS_FIGHT', 'ENDED'
        let mobCount = CONFIG.startCount;
        let playerZ = 0; // 玩家前進距離 (負數往前)
        let playerX = 0; // 玩家左右位置
        let targetX = 0; // 滑鼠目標位置

        // --- Three.js 初始化 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 30, 90);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 15, 20);
        camera.lookAt(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 燈光
        const ambiLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 30, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 地板 (跑道)
        // 為了節省資源，地板跟著玩家移動
        const floorGeo = new THREE.PlaneGeometry(CONFIG.laneWidth + 20, 200);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- 人群系統 (InstancedMesh) ---
        const unitGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
        unitGeo.translate(0, 0.6, 0);
        const unitMat = new THREE.MeshLambertMaterial({ color: 0x00e5ff });
        const mesh = new THREE.InstancedMesh(unitGeo, unitMat, CONFIG.maxInstances);
        mesh.frustumCulled = false; // 關鍵修正：防止人群在畫面邊緣消失
        mesh.castShadow = true;
        scene.add(mesh);

        const dummy = new THREE.Object3D();
        // 預先計算好的隨機偏移量，形成圓形隊伍
        const offsets = [];
        for(let i=0; i<CONFIG.maxInstances; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.sqrt(Math.random()); // 均勻分佈
            offsets.push({
                x: Math.cos(angle) * r,
                z: Math.sin(angle) * r,
                speed: 0.1 + Math.random() * 0.1, // 打王時的攻擊速度
                dead: false // 打王時是否已犧牲
            });
        }

        // --- 關卡物件 (門) ---
        const gates = [];
        const gateGroup = new THREE.Group();
        scene.add(gateGroup);

        function createGateTexture(text, isGood) {
            const cvs = document.createElement('canvas');
            cvs.width = 256; cvs.height = 128;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = isGood ? 'rgba(0, 100, 255, 0.6)' : 'rgba(255, 50, 50, 0.6)';
            ctx.fillRect(0,0,256,128);
            ctx.strokeStyle = "white";
            ctx.lineWidth = 10;
            ctx.strokeRect(0,0,256,128);
            ctx.fillStyle = "white";
            ctx.font = "bold 80px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 128, 64);
            return new THREE.CanvasTexture(cvs);
        }

        // 生成關卡
        function generateLevel() {
            for (let i = 1; i <= CONFIG.gateCount; i++) {
                const zPos = -i * CONFIG.gateInterval;
                
                // 門的邏輯
                const isLeft = Math.random() > 0.5;
                const type = Math.random() > 0.6 ? 'mult' : 'add'; // 40% 機率是乘法
                
                let val, text;
                if(type === 'mult') {
                    val = Math.floor(Math.random() * 3) + 2; // x2 ~ x4
                    text = "x" + val;
                } else {
                    val = Math.floor(Math.random() * 50) + 10; // +10 ~ +60
                    text = "+" + val;
                }

                // 創建門的模型
                const gateGeo = new THREE.BoxGeometry(6, 4, 0.5);
                const gateMat = new THREE.MeshBasicMaterial({ map: createGateTexture(text, true), transparent: true });
                const gate = new THREE.Mesh(gateGeo, gateMat);
                
                // 位置：左(-3.5) 或 右(3.5)
                gate.position.set(isLeft ? -3.5 : 3.5, 2, zPos);
                gate.userData = { type: type, value: val, hit: false, id: i };
                
                gateGroup.add(gate);
                gates.push(gate);

                // 在另一邊生成一個較差的選項
                const badVal = Math.floor(Math.random() * 10) + 1;
                const badGateMat = new THREE.MeshBasicMaterial({ map: createGateTexture("+" + badVal, false), transparent: true });
                const badGate = new THREE.Mesh(gateGeo, badGateMat);
                badGate.position.set(isLeft ? 3.5 : -3.5, 2, zPos);
                badGate.userData = { type: 'add', value: badVal, hit: false, id: i };
                gateGroup.add(badGate);
                gates.push(badGate);
            }
        }
        generateLevel();

        // --- Boss 系統 ---
        let boss;
        let currentBossHP = CONFIG.bossHP;
        const bossZ = -(CONFIG.gateCount * CONFIG.gateInterval) - 40; // 在最後一道門之後

        function initBoss() {
            const geo = new THREE.BoxGeometry(10, 20, 10);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            boss = new THREE.Mesh(geo, mat);
            boss.position.set(0, 10, bossZ);
            scene.add(boss);

            // Boss 的地板裝飾
            const zoneGeo = new THREE.CircleGeometry(20, 32);
            const zoneMat = new THREE.MeshBasicMaterial({ color: 0x550000 });
            const zone = new THREE.Mesh(zoneGeo, zoneMat);
            zone.rotation.x = -Math.PI/2;
            zone.position.set(0, 0.1, bossZ);
            scene.add(zone);
        }
        initBoss();

        // --- 輸入控制 ---
        function onInput(x) {
            if (state !== 'RUNNING') return;
            const ndc = (x / window.innerWidth) * 2 - 1; // -1 to 1
            targetX = ndc * (CONFIG.laneWidth / 2);
        }
        document.addEventListener('mousemove', e => onInput(e.clientX));
        document.addEventListener('touchmove', e => onInput(e.touches[0].clientX));

        // --- 遊戲邏輯 ---

        function updateMobFormation() {
            // 根據人數決定隊伍半徑
            let radius = Math.sqrt(mobCount) * 0.15;
            if (radius < 2) radius = 2;
            if (radius > CONFIG.laneWidth / 2) radius = CONFIG.laneWidth / 2; // 限制寬度

            let visibleCount = 0;
            for (let i = 0; i < CONFIG.maxInstances; i++) {
                if (i < mobCount) {
                    if (state === 'RUNNING') {
                        // 跑酷模式：跟隨玩家 X，Z 軸固定相對位置
                        const ox = offsets[i].x * radius;
                        const oz = offsets[i].z * radius;
                        
                        dummy.position.set(
                            playerX + ox, 
                            0, 
                            playerZ + oz
                        );
                        dummy.rotation.x = -0.2; // 跑步前傾
                        dummy.rotation.z = 0;
                    } else if (state === 'BOSS_FIGHT' && !offsets[i].dead) {
                        // Boss 戰模式：衝向 Boss
                        // 計算目前位置
                        let currX = playerX + offsets[i].x * radius; // 凍結時的 X
                        let currZ = playerZ + offsets[i].z * radius; // 凍結時的 Z
                        
                        // 簡單模擬：讓它們每幀往 Boss 靠近
                        // 為了效能，我們這裡做一個簡單的視覺欺騙
                        // 實際上我們只更新 dummy 的位置往 Boss 飛去
                        
                        // 重新計算當前小人的位置 (這裡簡化，假設他們從隊伍中心出發)
                        // 為了讓動畫好看，我們需要記錄每個小人的當前世界座標，這比較複雜
                        // 這裡使用簡化算法：隨機從前方發射
                        
                        const speed = 1.5;
                        const distToBoss = Math.abs(bossZ - playerZ);
                        // 讓小人隨時間往前飛
                        // 這裡使用 offsets[i].speed 作為時間偏移
                        
                        // 簡單處理：小人保持在原地，但不斷往 Z 軸深處衝
                        dummy.position.set(
                            (Math.random()-0.5) * 10, // 亂竄
                            0,
                            bossZ + 15 + Math.random() * 20 // 圍繞在 Boss 前
                        );
                    } else {
                        // 死了或不該顯示
                         dummy.position.set(0, -100, 0);
                    }
                    
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    visibleCount++;
                } else {
                    // 隱藏多餘的
                    dummy.position.set(0, -500, 0); // 移到更遠的地方
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
            }
            mesh.instanceMatrix.needsUpdate = true;
        }

        // 專門處理 Boss 戰的動畫
        let attackTimer = 0;
        function updateBossFight() {
            if (state !== 'BOSS_FIGHT') return;

            // 調整相機視角
            camera.position.x += (20 - camera.position.x) * 0.05;
            camera.position.z = bossZ + 60;
            camera.position.y = 30;
            camera.lookAt(0, 5, bossZ);

            // 攻擊邏輯
            attackTimer++;
            const attackRate = 5; // 每幾幀攻擊一次
            
            // 每次攻擊讓一定數量的小人衝上去 "自殺" 換取傷害
            const unitsPerWave = Math.floor(mobCount / 50) + 1; // 人越多攻速越快
            
            if (mobCount > 0 && currentBossHP > 0) {
                mobCount -= unitsPerWave;
                if (mobCount < 0) mobCount = 0;
                
                // 扣血
                const damage = unitsPerWave * 10; // 為了視覺效果，每波扣多一點
                // 精確計算：總傷害 = 總人數 * 0.3
                // 這裡模擬：每幀扣除 (0.3) * unitsPerWave
                currentBossHP -= unitsPerWave * CONFIG.damagePerUnit;
                
                // Boss 受傷動畫 (變白)
                if (Math.random() > 0.5) boss.material.color.setHex(0xffffff);
                else boss.material.color.setHex(0xff0000);

                // 更新 UI
                document.getElementById('mob-count').innerText = mobCount;
                const hpPercent = (currentBossHP / CONFIG.bossHP) * 100;
                document.getElementById('boss-hp-fill').style.width = hpPercent + "%";
            } else {
                boss.material.color.setHex(0xff0000);
            }

            // 判定勝負
            if (currentBossHP <= 0) {
                state = 'ENDED';
                document.getElementById('game-over').innerText = "VICTORY!";
                document.getElementById('game-over').style.display = "block";
                document.getElementById('game-over').style.color = "#00ff00";
                boss.visible = false; // Boss 消失
            } else if (mobCount <= 0) {
                state = 'ENDED';
                document.getElementById('game-over').innerText = "DEFEAT...";
                document.getElementById('game-over').style.display = "block";
                document.getElementById('game-over').style.color = "red";
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (state === 'RUNNING') {
                // 1. 移動
                playerZ -= CONFIG.runSpeed;
                playerX += (targetX - playerX) * 0.1;

                // 地板跟隨 (無限延伸感)
                floor.position.z = playerZ;

                // 相機跟隨
                camera.position.z = playerZ + 25;
                camera.position.x = playerX * 0.3;

                // 2. 檢測門的碰撞
                // 優化：只檢查最近的門
                for (let g of gates) {
                    if (!g.userData.hit) {
                        // Z 軸距離接近
                        if (Math.abs(g.position.z - playerZ) < 1) {
                            // X 軸距離接近 (寬度約6)
                            if (Math.abs(g.position.x - playerX) < 3.5) {
                                // 觸發效果
                                const type = g.userData.type;
                                const val = g.userData.value;
                                
                                let newCount = mobCount;
                                if (type === 'add') newCount += val;
                                if (type === 'mult') newCount *= val;
                                
                                if (newCount > CONFIG.maxInstances) newCount = CONFIG.maxInstances;
                                mobCount = Math.floor(newCount);
                                
                                // UI 更新
                                document.getElementById('mob-count').innerText = mobCount;
                                
                                // 標記這對門都已失效 (防止重複撞)
                                const pairId = g.userData.id;
                                gates.forEach(og => { if(og.userData.id === pairId) { og.userData.hit = true; og.visible = false; }});
                            }
                        }
                    }
                }

                // 3. 檢測是否到達 Boss
                if (playerZ < bossZ + 30) {
                    state = 'BOSS_FIGHT';
                    document.getElementById('boss-ui').style.display = 'block';
                }

                updateMobFormation();
            } else if (state === 'BOSS_FIGHT') {
                updateBossFight();
                // 在 Boss 戰中，updateMobFormation 需要特殊處理或停止標準更新
                // 這裡我們簡單地讓它顯示最後的人數，具體攻擊動畫在 updateBossFight 模擬
            }
            
            renderer.render(scene, camera);
        }

        // 視窗調整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
